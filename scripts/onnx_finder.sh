#!/bin/bash

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Function to print messages
log() {
    echo -e "${GREEN}[ONNX-FINDER]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Get Homebrew prefix
HOMEBREW_PREFIX=$(brew --prefix)
log "Homebrew prefix: ${HOMEBREW_PREFIX}"

# Check if onnxruntime is installed
if brew list onnxruntime &>/dev/null; then
    ONNX_VERSION=$(brew list --versions onnxruntime | awk '{print $2}')
    log "Found ONNX Runtime version: ${ONNX_VERSION}"
else
    error "ONNX Runtime is not installed via Homebrew"
    exit 1
fi

# Path to check
ONNX_ROOT="${HOMEBREW_PREFIX}/opt/onnxruntime"
ONNX_INCLUDE="${ONNX_ROOT}/include"
ONNX_LIB="${ONNX_ROOT}/lib"

log "ONNX Runtime paths:"
log "  Root: ${ONNX_ROOT}"
log "  Include: ${ONNX_INCLUDE}"
log "  Library: ${ONNX_LIB}"

# Find the onnxruntime_cxx_api.h file
log "Looking for onnxruntime_cxx_api.h..."
CXX_API_PATHS=$(find "${ONNX_INCLUDE}" -name "onnxruntime_cxx_api.h" 2>/dev/null)

if [ -z "${CXX_API_PATHS}" ]; then
    error "Could not find onnxruntime_cxx_api.h in ${ONNX_INCLUDE}"
    
    # Check if it might be in Cellar instead
    log "Checking in Homebrew Cellar..."
    CELLAR_PATH="${HOMEBREW_PREFIX}/Cellar/onnxruntime/${ONNX_VERSION}"
    CXX_API_PATHS=$(find "${CELLAR_PATH}" -name "onnxruntime_cxx_api.h" 2>/dev/null)
    
    if [ -z "${CXX_API_PATHS}" ]; then
        error "Could not find onnxruntime_cxx_api.h in Cellar either"
        exit 1
    else
        log "Found in Cellar: ${CXX_API_PATHS}"
        ONNX_INCLUDE=$(dirname "${CXX_API_PATHS}")
        log "Updated include path: ${ONNX_INCLUDE}"
    fi
else
    log "Found: ${CXX_API_PATHS}"
fi

# Check for other important header files
log "Looking for other important headers..."
for HEADER in "cpu_provider_factory.h" "coreml_provider_factory.h"; do
    HEADER_PATHS=$(find "${ONNX_INCLUDE}" -name "${HEADER}" 2>/dev/null)
    if [ -z "${HEADER_PATHS}" ]; then
        warn "Could not find ${HEADER}"
    else
        log "Found ${HEADER}: ${HEADER_PATHS}"
    fi
done

# Create a simple test file to check inclusion
TEST_DIR=$(mktemp -d)
TEST_FILE="${TEST_DIR}/test_onnx.cpp"

log "Creating a simple test file at ${TEST_FILE}..."
cat > "${TEST_FILE}" << EOF
#include <iostream>
#include <onnxruntime_cxx_api.h>

int main() {
    std::cout << "ONNX Runtime test successful!" << std::endl;
    return 0;
}
EOF

log "Trying to compile the test file..."
g++ -I"${ONNX_INCLUDE}" "${TEST_FILE}" -o "${TEST_DIR}/test_onnx" 2> "${TEST_DIR}/compile_errors.txt"

if [ $? -eq 0 ]; then
    log "Compilation successful!"
else
    error "Compilation failed. Error log:"
    cat "${TEST_DIR}/compile_errors.txt"
fi

# Generate CMakeLists.txt.user file based on findings
log "Generating CMakeLists.txt.user file..."

if [[ "${CXX_API_PATHS}" == *"/onnxruntime/core/"* ]]; then
    log "Detected nested header structure"
    HEADER_STRUCTURE="NESTED"
else
    log "Detected flat header structure"
    HEADER_STRUCTURE="FLAT"
fi

cat > "CMakeLists.txt.user" << EOF
# CMakeLists.txt.user - Auto-generated by ONNX finder script
message(STATUS "Loading auto-generated ONNXRuntime configuration")

# Explicitly set ONNXRuntime paths for MacOS
if(APPLE)
    # Set paths using detected ONNX Runtime installation
    set(ONNXRuntime_ROOT "${ONNX_ROOT}")
    set(ONNXRuntime_INCLUDE_DIRS "${ONNX_INCLUDE}")
    set(ONNXRuntime_LIBRARIES "${ONNX_LIB}/libonnxruntime.dylib")
    
    # Add this to make find_package happy
    set(ONNXRuntime_FOUND TRUE)
    
    # Create an adapter include directory at build time
    set(ONNX_ADAPTER_DIR "\${CMAKE_BINARY_DIR}/onnx_adapter")
    file(MAKE_DIRECTORY \${ONNX_ADAPTER_DIR})
    
    # Configure header adapters based on detected structure
EOF

if [ "${HEADER_STRUCTURE}" = "FLAT" ]; then
    cat >> "CMakeLists.txt.user" << EOF
    # Using flat include structure
    message(STATUS "Using flat header structure")
    
    file(WRITE "\${ONNX_ADAPTER_DIR}/onnxruntime_cxx_api.h" 
         "#include <onnxruntime_cxx_api.h>\n")
    
    file(WRITE "\${ONNX_ADAPTER_DIR}/cpu_provider_factory.h" 
         "#include <cpu_provider_factory.h>\n")
    
    if(EXISTS "${ONNX_INCLUDE}/coreml_provider_factory.h")
        file(WRITE "\${ONNX_ADAPTER_DIR}/onnxruntime_coreml_provider_factory.h" 
             "#include <coreml_provider_factory.h>\n")
    endif()
EOF
else
    cat >> "CMakeLists.txt.user" << EOF
    # Using nested include structure
    message(STATUS "Using nested header structure")
    
    file(WRITE "\${ONNX_ADAPTER_DIR}/onnxruntime_cxx_api.h" 
         "#include <onnxruntime/core/session/onnxruntime_cxx_api.h>\n")
    
    file(WRITE "\${ONNX_ADAPTER_DIR}/cpu_provider_factory.h" 
         "#include <onnxruntime/core/providers/cpu/cpu_provider_factory.h>\n")
    
    if(EXISTS "${ONNX_INCLUDE}/onnxruntime/core/providers/coreml/coreml_provider_factory.h")
        file(WRITE "\${ONNX_ADAPTER_DIR}/onnxruntime_coreml_provider_factory.h" 
             "#include <onnxruntime/core/providers/coreml/coreml_provider_factory.h>\n")
    endif()
EOF
fi

cat >> "CMakeLists.txt.user" << EOF
    
    # Additional adapter for header in onnx_model.h
    file(WRITE "\${ONNX_ADAPTER_DIR}/PROVIDER_HEADER" 
         "#define PROVIDER_HEADER(provider) <onnxruntime_##provider##_provider_factory.h>\n")
    
    # Add the adapter directory to the include path (before other includes)
    include_directories(BEFORE \${ONNX_ADAPTER_DIR})
    
    # Set specific flags for M4 processor
    if(CMAKE_SYSTEM_PROCESSOR MATCHES "arm64")
        message(STATUS "Setting optimization flags for M4 processor")
        set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -mcpu=apple-a14 -O3")
    endif()
    
    # Debug output
    message(STATUS "Using ONNX Runtime configuration:")
    message(STATUS "  ONNXRuntime_ROOT: \${ONNXRuntime_ROOT}")
    message(STATUS "  ONNXRuntime_INCLUDE_DIRS: \${ONNXRuntime_INCLUDE_DIRS}")
    message(STATUS "  ONNXRuntime_LIBRARIES: \${ONNXRuntime_LIBRARIES}")
    message(STATUS "  ONNX_ADAPTER_DIR: \${ONNX_ADAPTER_DIR}")
    message(STATUS "  ONNX Runtime version: ${ONNX_VERSION}")
    message(STATUS "  Header structure: ${HEADER_STRUCTURE}")
endif()
EOF

# Create a direct symlink solution
log "Creating a direct symlink solution script..."

cat > "fix_onnx_headers.sh" << EOF
#!/bin/bash

# This script creates symlinks to ONNX Runtime headers in the expected locations
# Run this if the other solutions don't work

mkdir -p onnxruntime/core/session
mkdir -p onnxruntime/core/providers/cpu
mkdir -p onnxruntime/core/providers/coreml

# Create symlinks to the actual header files
ln -sf "${ONNX_INCLUDE}/onnxruntime_cxx_api.h" onnxruntime/core/session/
ln -sf "${ONNX_INCLUDE}/cpu_provider_factory.h" onnxruntime/core/providers/cpu/
if [ -f "${ONNX_INCLUDE}/coreml_provider_factory.h" ]; then
    ln -sf "${ONNX_INCLUDE}/coreml_provider_factory.h" onnxruntime/core/providers/coreml/
fi

# Set up CMake to use these symlinks
echo "add_compile_options(-I\${CMAKE_CURRENT_SOURCE_DIR})" > symlink_include.cmake
echo "message(STATUS \"Using symlinked ONNX Runtime headers in \${CMAKE_CURRENT_SOURCE_DIR}/onnxruntime\")" >> symlink_include.cmake

echo "To use the symlink solution:"
echo "1. Run: chmod +x fix_onnx_headers.sh"
echo "2. Run: ./fix_onnx_headers.sh"
echo "3. Add this line to your CMakeLists.txt after cmake_minimum_required():"
echo "   include(symlink_include.cmake OPTIONAL)"
EOF

chmod +x fix_onnx_headers.sh

log "Done! Please review the generated files:"
log "1. CMakeLists.txt.user - Auto-generated configuration"
log "2. fix_onnx_headers.sh - Alternative symlink solution if CMake approach fails"
log ""
log "Next steps:"
log "1. Clean your build directory: rm -rf build/*"
log "2. Run the build script: ./build.sh"
log "3. If errors persist, try the symlink solution: ./fix_onnx_headers.sh"